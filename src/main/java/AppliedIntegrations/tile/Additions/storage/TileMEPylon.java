package AppliedIntegrations.tile.Additions.storage;

import AppliedIntegrations.API.AIApi;
import AppliedIntegrations.API.Botania.IManaStorageChannel;
import AppliedIntegrations.API.ISingularity;
import AppliedIntegrations.API.Storage.IEnergyStorageChannel;
import AppliedIntegrations.Blocks.Additions.BlockMEPylon;
import AppliedIntegrations.Integration.Botania.BotaniaLoader;
import AppliedIntegrations.Utils.AILog;
import AppliedIntegrations.grid.EnergyStorageChannel;
import AppliedIntegrations.tile.AITile;
import AppliedIntegrations.tile.Additions.singularities.TileBlackHole;
import AppliedIntegrations.tile.Additions.singularities.TileWhiteHole;
import AppliedIntegrations.API.Storage.helpers.BlackHoleSingularityInventoryHandler;
import AppliedIntegrations.API.Storage.helpers.WhiteHoleSingularityInventoryHandler;
import AppliedIntegrations.tile.Additions.storage.helpers.impl.*;
import appeng.api.AEApi;
import appeng.api.networking.IGrid;
import appeng.api.networking.IGridNode;
import appeng.api.networking.events.MENetworkCellArrayUpdate;
import appeng.api.storage.ICellContainer;
import appeng.api.storage.ICellInventory;
import appeng.api.storage.IMEInventoryHandler;
import appeng.api.storage.IStorageChannel;
import appeng.api.storage.channels.IFluidStorageChannel;
import appeng.api.storage.channels.IItemStorageChannel;
import appeng.api.util.AEPartLocation;
import appeng.util.Platform;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.Loader;

import javax.annotation.Nullable;
import java.util.*;

import static AppliedIntegrations.Blocks.Additions.BlockMEPylon.FACING;
import static java.util.Collections.singletonList;

public class TileMEPylon extends AITile implements ICellContainer {

    // Linked maps of *passive* handlers, which standing as handler factory
    private static LinkedHashMap<IStorageChannel, Class<? extends BlackHoleSingularityInventoryHandler<?>>> passiveBlackHoleHandlers = new LinkedHashMap<>();
    private static LinkedHashMap<IStorageChannel, Class<? extends WhiteHoleSingularityInventoryHandler<?>>> passiveWhiteHoleHandlers = new LinkedHashMap<>();

    // Linked maps of *active* handlers, which is generated by passive maps and used by current pylon
    private LinkedHashMap<IStorageChannel, BlackHoleSingularityInventoryHandler<?>> activeBlackHoleHandlers = new LinkedHashMap<>();
    private LinkedHashMap<IStorageChannel, WhiteHoleSingularityInventoryHandler<?>> activeWhiteHoleHandlers = new LinkedHashMap<>();

    private boolean activeHandlersLoaded = false;

    public ISingularity operatedTile;

    public boolean syncActive = false;

    // Adds new handler for black hole storage
    public static void addBlackHoleHandler(Class<? extends BlackHoleSingularityInventoryHandler<?>> handlerClassA, IStorageChannel chan) {
        // Log
        AILog.info("Adding new black hole storage handler for ME Pylon: " + handlerClassA.toString());
        // Add handler class
        passiveBlackHoleHandlers.put(chan,  handlerClassA);
    }

    // Adds new handler for white hole storage
    public static void addWhiteHoleHandler(Class<? extends WhiteHoleSingularityInventoryHandler<?>> handlerClassB, IStorageChannel chan) {
        // Log
        AILog.info("Adding new white hole storage handler for ME Pylon: " + handlerClassB.toString());
        // Add handler class
        passiveWhiteHoleHandlers.put(chan, handlerClassB);
    }

    public void initHandlers(){
        // Check loaded
        if(activeHandlersLoaded)
            return;

        // Check has singularity
        if(!hasSingularity())
            return;

        // Add handlers
        AIApi.instance().addHandlersForMEPylon(BlackHoleItemHandler.class, WhiteHoleItemHandler.class, AEApi.instance().storage().getStorageChannel(IItemStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleFluidHandler.class, WhiteHoleFluidHandler.class, AEApi.instance().storage().getStorageChannel(IFluidStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleEnergyHandler.class, WhiteHoleEnergyHandler.class, AEApi.instance().storage().getStorageChannel(IEnergyStorageChannel.class));

        // Check if botania loaded
        if(Loader.isModLoaded("botania")) {
            AIApi.instance().addHandlersForMEPylon(BlackHoleManaHandler.class, WhiteHoleManaHandler.class, AEApi.instance().storage().getStorageChannel(IManaStorageChannel.class));
        }

        // Create maps
        activeWhiteHoleHandlers = new LinkedHashMap<>();
        activeBlackHoleHandlers = new LinkedHashMap<>();

        // Iterate over all channels
        for(IStorageChannel chan : AEApi.instance().storage().storageChannels()){
            try {
                // Get inv
                WhiteHoleSingularityInventoryHandler<?> invWhiteHole = passiveWhiteHoleHandlers.get(chan).newInstance();
                BlackHoleSingularityInventoryHandler<?> invBlackHole = passiveBlackHoleHandlers.get(chan).newInstance();

                // Set singularity
                invWhiteHole.setSingularity(operatedTile);
                invBlackHole.setSingularity(operatedTile);

                // Fill up maps
                activeBlackHoleHandlers.put(chan, invBlackHole);
                activeWhiteHoleHandlers.put(chan, invWhiteHole);

            }catch (Exception e){
                AILog.info(e.getMessage());
            }
        }

        activeHandlersLoaded = true;
    }

    public boolean hasSingularity() {
        return operatedTile != null;
    }

    public void postCellEvent(){
        // Get node
        IGridNode node = getGridNode(AEPartLocation.INTERNAL);
        // Check notNull
        if (node != null) {
            // Get grid
            IGrid grid = node.getGrid();
            // Check not null
            if(grid != null) {
                // Post update
                grid.postEvent(new MENetworkCellArrayUpdate());
            }
        }
    }

    @Override
    public void update() {
        super.update();

        // Call only on server
        if(!world.isRemote){
            // Check if handlers not exist yet
            if(!activeHandlersLoaded) {
                // Init handlers
                initHandlers();
            }
        }

        if(getGridNode() == null)
            return;

        // Check if node was active
        if(!syncActive && getGridNode().isActive()){
            // Node wasn't active, but now it is active
            // Fire new cell array update event!
            postCellEvent();
            // Update sync
            syncActive = true;
        }else if(syncActive && !getGridNode().isActive()){
            // Node was active, but now it not
            // Fire new cell array update event!
            postCellEvent();
            // Update sync
            syncActive = false;
        }
    }

    @Override
    public void createAENode() {
        if(world != null) {
            if (!world.isRemote) {
                gridNode = AEApi.instance().grid().createGridNode(this);
                gridNode.updateState();

                // Fire new cell array update event!
                postCellEvent();
            }
        }
    }

    @Override
    public void blinkCell(int i) {}

    @Override
    public List<IMEInventoryHandler> getCellArray(IStorageChannel<?> iStorageChannel) {
        // Check if handlers exist
        if(!activeHandlersLoaded){
            // Create them
            initHandlers();

            // Return null array
            return new ArrayList<>();
        }

        // return empty list
        if(!hasSingularity() || !getGridNode().isActive())
            return new ArrayList<>();

        // Check if we are operating black hole
        if(operatedTile instanceof TileBlackHole)
            return singletonList(activeBlackHoleHandlers.get(iStorageChannel));
        // Check if we are operating white hole
        else
            return singletonList(activeWhiteHoleHandlers.get(iStorageChannel));
    }

    @Override
    public EnumSet<EnumFacing> getConnectableSides() {
        // Return opposite of facing side
        return EnumSet.of(world.getBlockState(pos).getValue(FACING).rotateY().getOpposite());
    }

    @Override
    public int getPriority() {
        return 0;
    }

    @Override
    public void saveChanges(@Nullable ICellInventory<?> iCellInventory) {
        // Check if inventory not null
        if (iCellInventory != null)
            // Persist inventory
            iCellInventory.persist();
        // Mark dirty
        world.markChunkDirty(pos, this);
    }

    public boolean activate(EnumHand hand, EntityPlayer p) {
        if(hand == EnumHand.MAIN_HAND) {
            if (!world.isRemote) {
                //AILog.chatLog("Has grid: " + (getGridNode().getGrid() != null) + " Active: " + getGridNode().isActive() + " Has singularity: " + hasSingularity());
            }
        }
        return true;
    }
}
