package AppliedIntegrations.tile.HoleStorageSystem.storage;
import AppliedIntegrations.AIConfig;
import AppliedIntegrations.Blocks.Additions.BlockBlackHole;
import AppliedIntegrations.Network.NetworkHandler;
import AppliedIntegrations.Network.Packets.HoleStorage.PacketPylonSingularitySync;
import AppliedIntegrations.Utils.AILog;
import AppliedIntegrations.api.AIApi;
import AppliedIntegrations.api.BlackHoleSystem.IPylon;
import AppliedIntegrations.api.BlackHoleSystem.ISingularity;
import AppliedIntegrations.api.Botania.IManaStorageChannel;
import AppliedIntegrations.api.Storage.IEnergyStorageChannel;
import AppliedIntegrations.api.Storage.helpers.BlackHoleSingularityInventoryHandler;
import AppliedIntegrations.api.Storage.helpers.WhiteHoleSingularityInventoryHandler;
import AppliedIntegrations.tile.HoleStorageSystem.AITileStorageCell;
import AppliedIntegrations.tile.HoleStorageSystem.TimeHandler;
import AppliedIntegrations.tile.HoleStorageSystem.singularities.TileBlackHole;
import AppliedIntegrations.tile.HoleStorageSystem.storage.helpers.impl.*;
import appeng.api.AEApi;
import appeng.api.config.Actionable;
import appeng.api.config.PowerMultiplier;
import appeng.api.networking.IGridNode;
import appeng.api.networking.energy.IEnergyGrid;
import appeng.api.networking.ticking.IGridTickable;
import appeng.api.networking.ticking.TickRateModulation;
import appeng.api.storage.ICellContainer;
import appeng.api.storage.IMEInventoryHandler;
import appeng.api.storage.IStorageChannel;
import appeng.api.storage.channels.IFluidStorageChannel;
import appeng.api.storage.channels.IItemStorageChannel;
import appeng.util.Platform;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.Loader;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;

import static AppliedIntegrations.Blocks.Additions.BlockMEPylon.FACING;
import static java.util.Collections.singletonList;
import static java.util.EnumSet.of;

/**
 * @Author Azazell
 */
public class TileMEPylon extends AITileStorageCell implements ICellContainer, IGridTickable, IPylon {
	public static final int DRAIN_LASTS_SECONDS = 3;

	// Linked maps of *passive* handlers, which standing as handler factory
	private static LinkedHashMap<IStorageChannel, Class<? extends BlackHoleSingularityInventoryHandler<?>>> passiveBlackHoleHandlers = new LinkedHashMap<>();
	private static LinkedHashMap<IStorageChannel, Class<? extends WhiteHoleSingularityInventoryHandler<?>>> passiveWhiteHoleHandlers = new LinkedHashMap<>();

	public ISingularity operatedTile;
	public float beamDrain = 0F;
	public boolean shouldDrain = false;
	public TimeHandler drainHandler = new TimeHandler();

	// Linked maps of *active* handlers, which is generated by passive maps and used by current pylon
	private LinkedHashMap<IStorageChannel, BlackHoleSingularityInventoryHandler<?>> activeBlackHoleHandlers = new LinkedHashMap<>();
	private LinkedHashMap<IStorageChannel, WhiteHoleSingularityInventoryHandler<?>> activeWhiteHoleHandlers = new LinkedHashMap<>();

	private boolean activeHandlersLoaded = false;

	private boolean configured = false;

	public static void addBlackHoleHandler(Class<? extends BlackHoleSingularityInventoryHandler<?>> handlerClassA, IStorageChannel chan) {
		passiveBlackHoleHandlers.put(chan, handlerClassA);
	}

	public static void addWhiteHoleHandler(Class<? extends WhiteHoleSingularityInventoryHandler<?>> handlerClassB, IStorageChannel chan) {
		passiveWhiteHoleHandlers.put(chan, handlerClassB);
	}

	private void notifyClient() {
		// Notify client
		//NetworkHandler.sendToAllInRange(new PacketPylonSingularitySync(this.operatedTile, getBeamState(), shouldDrain, this.getPos()), new NetworkRegistry.TargetPoint(world.provider.getDimension(), pos.getX(), pos.getY(), pos.getZ(), 64));
		NetworkHandler.sendToAll(new PacketPylonSingularitySync(this.operatedTile, getBeamState(), shouldDrain, this.getPos()));
	}

	@Nonnull
	@Override
	public TickRateModulation tickingRequest(@Nonnull IGridNode node, int ticksSinceLastCall) {
		TickRateModulation superTickRate = super.tickingRequest(node, ticksSinceLastCall);

		if (Platform.isServer()) {
			if (!configured) {
				getProxy().setValidSides(of(getFw().getOpposite()));
				configured = true;
			}

			if (!activeHandlersLoaded) {
				initHandlers();
			}

			if (node.isActive()) {
				if (!hasSingularity()) {
					tryToGetSingularity();
				} else if (shouldDrain) {
					if (!drainHandler.hasTimePassed(world, DRAIN_LASTS_SECONDS)) {
						// Consume energy for data transmitting over beam
						IEnergyGrid energyGrid = node.getGrid().getCache(IEnergyGrid.class);
						double drain = energyGrid.extractAEPower(beamDrain, Actionable.SIMULATE, PowerMultiplier.CONFIG);
						energyGrid.extractAEPower(drain, Actionable.MODULATE, PowerMultiplier.CONFIG);
						notifyClient();
					} else {
						shouldDrain = false;
						notifyClient();
					}
				}
			}
		}

		return superTickRate;
	}

	private void tryToGetSingularity() {
		// Tries to finds singularity on beam starting from pylon's origin
		if (hasSingularity()) {
			return;
		}

		for (int i = 1; i < AIConfig.maxPylonDistance + 1; i++) {
			IBlockState state = world.getBlockState(pos.offset(getFw(), i));

			if (state.getBlock() instanceof BlockBlackHole) {
				setSingularity((ISingularity) world.getTileEntity(pos.offset(getFw(), i)));
				beamDrain = (float) Math.min(i * AIConfig.pylonDrain, 10000);
				notifyClient();
				break;
			} else if (!(state.getBlock() instanceof BlockAir)) {
				break;
			}
		}
	}

	@Override
	public void setSingularity(ISingularity singularity) {
		operatedTile = singularity;
		notifyClient();

		if (operatedTile != null) {
			operatedTile.addListener(this);
		}

		postCellInventoryEvent();
	}

	@Override
	public void setDrain(boolean newValue) {
		this.shouldDrain = newValue;
		this.drainHandler.updateData(this.getWorld());
	}

	@Override
	public List<IMEInventoryHandler> getCellArray(IStorageChannel<?> iStorageChannel) {
		if (!activeHandlersLoaded) {
			initHandlers();
			return new ArrayList<>();
		}

		if (!hasSingularity() || !getGridNode().isActive()) {
			return new ArrayList<>();
		}

		if (operatedTile instanceof TileBlackHole) {
			return singletonList(activeBlackHoleHandlers.get(iStorageChannel));
		} else {
			return singletonList(activeWhiteHoleHandlers.get(iStorageChannel));
		}
	}

	public void initHandlers() {
		if (activeHandlersLoaded) {
			return;
		}

		if (!hasSingularity()) {
			return;
		}

		AIApi.instance().addHandlersForMEPylon(BlackHoleItemHandler.class, WhiteHoleItemHandler.class, AEApi.instance().storage().getStorageChannel(IItemStorageChannel.class));
		AIApi.instance().addHandlersForMEPylon(BlackHoleFluidHandler.class, WhiteHoleFluidHandler.class, AEApi.instance().storage().getStorageChannel(IFluidStorageChannel.class));
		AIApi.instance().addHandlersForMEPylon(BlackHoleEnergyHandler.class, WhiteHoleEnergyHandler.class, AEApi.instance().storage().getStorageChannel(IEnergyStorageChannel.class));
		if (Loader.isModLoaded("botania") && AIConfig.enableManaFeatures) {
			AIApi.instance().addHandlersForMEPylon(BlackHoleManaHandler.class, WhiteHoleManaHandler.class, AEApi.instance().storage().getStorageChannel(IManaStorageChannel.class));
		}

		activeWhiteHoleHandlers = new LinkedHashMap<>();
		activeBlackHoleHandlers = new LinkedHashMap<>();
		for (IStorageChannel chan : AEApi.instance().storage().storageChannels()) {
			try {
				WhiteHoleSingularityInventoryHandler<?> invWhiteHole = passiveWhiteHoleHandlers.get(chan).newInstance();
				BlackHoleSingularityInventoryHandler<?> invBlackHole = passiveBlackHoleHandlers.get(chan).newInstance();

				invWhiteHole.setSingularity(operatedTile);
				invBlackHole.setSingularity(operatedTile);

				activeBlackHoleHandlers.put(chan, invBlackHole);
				activeWhiteHoleHandlers.put(chan, invWhiteHole);
			} catch (Exception e) {
				AILog.info(e.getMessage());
			}
		}

		activeHandlersLoaded = true;
	}

	public boolean hasSingularity() {
		return operatedTile != null;
	}

	public boolean activate(EnumHand hand, EntityPlayer p) {
		return false;
	}

	public float getBeamState() {
		return beamDrain;
	}

	public boolean drainsEnergy() {
		return shouldDrain;
	}

	private EnumFacing getFw() {
		return world.getBlockState(pos).getValue(FACING).rotateY();
	}
}
