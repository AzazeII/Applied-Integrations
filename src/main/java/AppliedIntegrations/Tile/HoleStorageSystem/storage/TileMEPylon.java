package AppliedIntegrations.Tile.HoleStorageSystem.storage;

import AppliedIntegrations.AIConfig;
import AppliedIntegrations.API.AIApi;
import AppliedIntegrations.API.Botania.IManaStorageChannel;
import AppliedIntegrations.API.ISingularity;
import AppliedIntegrations.API.Storage.IEnergyStorageChannel;
import AppliedIntegrations.API.Storage.helpers.BlackHoleSingularityInventoryHandler;
import AppliedIntegrations.API.Storage.helpers.WhiteHoleSingularityInventoryHandler;
import AppliedIntegrations.Blocks.Additions.BlockBlackHole;
import AppliedIntegrations.Network.NetworkHandler;
import AppliedIntegrations.Network.Packets.PacketSingularitySync;
import AppliedIntegrations.Utils.AILog;
import AppliedIntegrations.Tile.AITile;
import AppliedIntegrations.Tile.HoleStorageSystem.TimeHandler;
import AppliedIntegrations.Tile.HoleStorageSystem.singularities.TileBlackHole;
import AppliedIntegrations.Tile.HoleStorageSystem.storage.helpers.impl.*;
import appeng.api.AEApi;
import appeng.api.config.Actionable;
import appeng.api.config.PowerMultiplier;
import appeng.api.networking.IGrid;
import appeng.api.networking.IGridNode;
import appeng.api.networking.energy.IEnergyGrid;
import appeng.api.networking.events.MENetworkCellArrayUpdate;
import appeng.api.networking.ticking.IGridTickable;
import appeng.api.networking.ticking.TickRateModulation;
import appeng.api.networking.ticking.TickingRequest;
import appeng.api.storage.ICellContainer;
import appeng.api.storage.ICellInventory;
import appeng.api.storage.IMEInventoryHandler;
import appeng.api.storage.IStorageChannel;
import appeng.api.storage.channels.IFluidStorageChannel;
import appeng.api.storage.channels.IItemStorageChannel;
import appeng.api.util.AEPartLocation;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.network.NetworkRegistry;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.List;

import static AppliedIntegrations.Blocks.Additions.BlockMEPylon.FACING;
import static java.util.Collections.singletonList;

/**
 * @Author Azazell
 */
public class TileMEPylon extends AITile implements ICellContainer, IGridTickable {

    // Linked maps of *passive* handlers, which standing as handler factory
    private static LinkedHashMap<IStorageChannel, Class<? extends BlackHoleSingularityInventoryHandler<?>>> passiveBlackHoleHandlers = new LinkedHashMap<>();
    private static LinkedHashMap<IStorageChannel, Class<? extends WhiteHoleSingularityInventoryHandler<?>>> passiveWhiteHoleHandlers = new LinkedHashMap<>();

    // Linked maps of *active* handlers, which is generated by passive maps and used by current pylon
    private LinkedHashMap<IStorageChannel, BlackHoleSingularityInventoryHandler<?>> activeBlackHoleHandlers = new LinkedHashMap<>();
    private LinkedHashMap<IStorageChannel, WhiteHoleSingularityInventoryHandler<?>> activeWhiteHoleHandlers = new LinkedHashMap<>();

    private boolean activeHandlersLoaded = false;

    public ISingularity operatedTile;

    public boolean syncActive = false;

    // Drain in AE
    public float beamDrain = 0F;

    // Should this Tile drain energy from ME?
    public boolean shouldDrain = false;

    // How long drain continues?
    public static final int DRAIN_LASTS_SECONDS = 3;

    // Time handler for drain
    public TimeHandler drainHandler = new TimeHandler();

    // Adds new handler for black hole storage
    public static void addBlackHoleHandler(Class<? extends BlackHoleSingularityInventoryHandler<?>> handlerClassA, IStorageChannel chan) {
        // Add handler class
        passiveBlackHoleHandlers.put(chan,  handlerClassA);
    }

    // Adds new handler for white hole storage
    public static void addWhiteHoleHandler(Class<? extends WhiteHoleSingularityInventoryHandler<?>> handlerClassB, IStorageChannel chan) {
        // Add handler class
        passiveWhiteHoleHandlers.put(chan, handlerClassB);
    }

    public void initHandlers(){
        // Check loaded
        if(activeHandlersLoaded)
            return;

        // Check has singularity
        if(!hasSingularity())
            return;

        // Add handlers
        AIApi.instance().addHandlersForMEPylon(BlackHoleItemHandler.class, WhiteHoleItemHandler.class, AEApi.instance().storage().getStorageChannel(IItemStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleFluidHandler.class, WhiteHoleFluidHandler.class, AEApi.instance().storage().getStorageChannel(IFluidStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleEnergyHandler.class, WhiteHoleEnergyHandler.class, AEApi.instance().storage().getStorageChannel(IEnergyStorageChannel.class));

        // Check if botania loaded
        if(Loader.isModLoaded("botania") && AIConfig.enableManaFeatures) {
            AIApi.instance().addHandlersForMEPylon(BlackHoleManaHandler.class, WhiteHoleManaHandler.class, AEApi.instance().storage().getStorageChannel(IManaStorageChannel.class));
        }

        // Create maps
        activeWhiteHoleHandlers = new LinkedHashMap<>();
        activeBlackHoleHandlers = new LinkedHashMap<>();

        // Iterate over all channels
        for(IStorageChannel chan : AEApi.instance().storage().storageChannels()){
            try {
                // Get inv
                WhiteHoleSingularityInventoryHandler<?> invWhiteHole = passiveWhiteHoleHandlers.get(chan).newInstance();
                BlackHoleSingularityInventoryHandler<?> invBlackHole = passiveBlackHoleHandlers.get(chan).newInstance();

                // Set singularity
                invWhiteHole.setSingularity(operatedTile);
                invBlackHole.setSingularity(operatedTile);

                // Fill up maps
                activeBlackHoleHandlers.put(chan, invBlackHole);
                activeWhiteHoleHandlers.put(chan, invWhiteHole);

            }catch (Exception e){
                AILog.info(e.getMessage());
            }
        }

        activeHandlersLoaded = true;
    }

    public boolean hasSingularity() {
        return operatedTile != null;
    }

    public void postCellEvent(){
        // Get node
        IGridNode node = getGridNode(AEPartLocation.INTERNAL);
        // Check notNull
        if (node != null) {
            // Get Grid
            IGrid grid = node.getGrid();
            // Check not null
            if(grid != null) {
                // Post update
                grid.postEvent(new MENetworkCellArrayUpdate());
            }
        }
    }

    private void notifyClient(){
        // Notify client
        NetworkHandler.sendToAllInRange(new PacketSingularitySync(this.operatedTile, getBeamState(), shouldDrain, this.getPos()),
                new NetworkRegistry.TargetPoint(world.provider.getDimension(), pos.getX(), pos.getY(), pos.getZ(), 64));
    }

    @Nonnull
    @Override
    public TickingRequest getTickingRequest(@Nonnull IGridNode node) {
        return new TickingRequest(1,1, false, false);
    }

    @Nonnull
    @Override
    public TickRateModulation tickingRequest(@Nonnull IGridNode node, int ticksSinceLastCall) {
        // Call only on server
        if(!world.isRemote) {
            // Check if handlers not exist yet
            if (!activeHandlersLoaded) {
                // Init handlers
                initHandlers();
            }

            // Check if active
            if (getGridNode().isActive()) {
                // Check if has no handled black hole
                if (!hasSingularity()) {
                    tryToGetSingularity();
                } else if (shouldDrain) {
                    // Check if time not passed yet
                    if(!drainHandler.hasTimePassed(world, DRAIN_LASTS_SECONDS)) {
                        // Consume energy for data transmitting, over beam
                        IEnergyGrid energyGrid = getGridNode().getGrid().getCache(IEnergyGrid.class);

                        // Simulate drain, and check if Grid has enough energy
                        double drain = energyGrid.extractAEPower(beamDrain, Actionable.SIMULATE, PowerMultiplier.CONFIG);

                        // Drain energy
                        energyGrid.extractAEPower(drain, Actionable.MODULATE, PowerMultiplier.CONFIG);

                        // Sync client
                        notifyClient();
                    }else{
                        // Don't drain energy anymore
                        shouldDrain = false;

                        // Sync client
                        notifyClient();
                    }
                }
            }

            // Check if node was active
            if (!syncActive && getGridNode().isActive()) {
                // Node wasn't active, but now it is active
                // Fire new cell array update event!
                postCellEvent();
                // Update sync
                syncActive = true;
            } else if (syncActive && !getGridNode().isActive()) {
                // Node was active, but now it not
                // Fire new cell array update event!
                postCellEvent();
                // Update sync
                syncActive = false;
            }
        }
        return TickRateModulation.SAME;
    }

    private void tryToGetSingularity() {

        // Check if Tile already has singularity
        if(hasSingularity())
            return;

        // Check if Tile can indirectly see singularity
        for(int i = 1; i < AIConfig.maxPylonDistance+1; i++){
            // get block with offset
            IBlockState state = world.getBlockState(pos.offset(getFw(), i));

            // Check if block is singularity
            if(state.getBlock() instanceof BlockBlackHole) {
                // Set operated Tile
                setSingularity((ISingularity)world.getTileEntity(pos.offset(getFw(), i)));

                // Change energy drain to current iteration multiplied by config value
                beamDrain = (float)Math.min(i * AIConfig.pylonDrain, 10000);

                // Sync client
                notifyClient();

                // Skip other positions
                break;
            }else if(!(state.getBlock() instanceof BlockAir)){
                // ignore
                break;
            }
        }
    }

    public void setSingularity(ISingularity tileEntity) {
        // Set singularity
        operatedTile = tileEntity;

        // Sync client
        notifyClient();

        // Check Tile not resetting
        if( operatedTile != null )
            // Notify singularity
            operatedTile.addListener(this);

        // Post cell array update
        postCellEvent();
    }

    @Override
    public void createAENode() {
        if(world != null) {
            if (!world.isRemote) {
                gridNode = AEApi.instance().grid().createGridNode(this);
                gridNode.updateState();

                // Fire new cell array update event!
                postCellEvent();
            }
        }
    }

    @Override
    public void blinkCell(int i) {}

    @Override
    public List<IMEInventoryHandler> getCellArray(IStorageChannel<?> iStorageChannel) {
        // Check if handlers exist
        if(!activeHandlersLoaded){
            // Create them
            initHandlers();

            // Return null array
            return new ArrayList<>();
        }

        // return empty list
        if(!hasSingularity() || !getGridNode().isActive())
            return new ArrayList<>();

        // Check if we are operating black hole
        if(operatedTile instanceof TileBlackHole)
            return singletonList(activeBlackHoleHandlers.get(iStorageChannel));

        // Check if we are operating white hole
        else
            return singletonList(activeWhiteHoleHandlers.get(iStorageChannel));
    }

    @Override
    public EnumSet<EnumFacing> getConnectableSides() {
        // Return opposite of facing side
        return EnumSet.of(getFw().getOpposite());
    }

    private EnumFacing getFw() {
        return world.getBlockState(pos).getValue(FACING).rotateY();
    }

    @Override
    public int getPriority() {
        return 0;
    }

    @Override
    public void saveChanges(@Nullable ICellInventory<?> iCellInventory) {
        // Check if inventory not null
        if (iCellInventory != null)
            // Persist inventory
            iCellInventory.persist();
        // Mark dirty
        world.markChunkDirty(pos, this);
    }

    public boolean activate(EnumHand hand, EntityPlayer p) {
        return false;
    }

    public float getBeamState() {
        return beamDrain;
    }

    public boolean drainsEnergy(){
        return shouldDrain;
    }
}
