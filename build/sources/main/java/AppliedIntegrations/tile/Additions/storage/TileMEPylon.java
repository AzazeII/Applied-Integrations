package AppliedIntegrations.tile.Additions.storage;

import AppliedIntegrations.AIConfig;
import AppliedIntegrations.API.AIApi;
import AppliedIntegrations.API.Botania.IManaStorageChannel;
import AppliedIntegrations.API.ISingularity;
import AppliedIntegrations.API.Storage.IEnergyStorageChannel;
import AppliedIntegrations.API.Storage.helpers.BlackHoleSingularityInventoryHandler;
import AppliedIntegrations.API.Storage.helpers.WhiteHoleSingularityInventoryHandler;
import AppliedIntegrations.Blocks.Additions.BlockBlackHole;
import AppliedIntegrations.Network.NetworkHandler;
import AppliedIntegrations.Network.Packets.PacketSingularitySync;
import AppliedIntegrations.Utils.AILog;
import AppliedIntegrations.tile.AITile;
import AppliedIntegrations.tile.Additions.singularities.TileBlackHole;
import AppliedIntegrations.tile.Additions.storage.helpers.impl.*;
import appeng.api.AEApi;
import appeng.api.networking.IGrid;
import appeng.api.networking.IGridNode;
import appeng.api.networking.events.MENetworkCellArrayUpdate;
import appeng.api.networking.events.MENetworkEvent;
import appeng.api.storage.ICellContainer;
import appeng.api.storage.ICellInventory;
import appeng.api.storage.IMEInventoryHandler;
import appeng.api.storage.IStorageChannel;
import appeng.api.storage.channels.IFluidStorageChannel;
import appeng.api.storage.channels.IItemStorageChannel;
import appeng.api.util.AEPartLocation;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.network.NetworkRegistry;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.List;

import static AppliedIntegrations.Blocks.Additions.BlockMEPylon.FACING;
import static java.util.Collections.singletonList;

public class TileMEPylon extends AITile implements ICellContainer {

    // Linked maps of *passive* handlers, which standing as handler factory
    private static LinkedHashMap<IStorageChannel, Class<? extends BlackHoleSingularityInventoryHandler<?>>> passiveBlackHoleHandlers = new LinkedHashMap<>();
    private static LinkedHashMap<IStorageChannel, Class<? extends WhiteHoleSingularityInventoryHandler<?>>> passiveWhiteHoleHandlers = new LinkedHashMap<>();

    // Linked maps of *active* handlers, which is generated by passive maps and used by current pylon
    private LinkedHashMap<IStorageChannel, BlackHoleSingularityInventoryHandler<?>> activeBlackHoleHandlers = new LinkedHashMap<>();
    private LinkedHashMap<IStorageChannel, WhiteHoleSingularityInventoryHandler<?>> activeWhiteHoleHandlers = new LinkedHashMap<>();

    private boolean activeHandlersLoaded = false;
    private int IdleDrain = 0;

    public ISingularity operatedTile;

    public boolean syncActive = false;

    // Adds new handler for black hole storage
    public static void addBlackHoleHandler(Class<? extends BlackHoleSingularityInventoryHandler<?>> handlerClassA, IStorageChannel chan) {
        // Add handler class
        passiveBlackHoleHandlers.put(chan,  handlerClassA);
    }

    // Adds new handler for white hole storage
    public static void addWhiteHoleHandler(Class<? extends WhiteHoleSingularityInventoryHandler<?>> handlerClassB, IStorageChannel chan) {
        // Add handler class
        passiveWhiteHoleHandlers.put(chan, handlerClassB);
    }

    public void initHandlers(){
        // Check loaded
        if(activeHandlersLoaded)
            return;

        // Check has singularity
        if(!hasSingularity())
            return;

        // Add handlers
        AIApi.instance().addHandlersForMEPylon(BlackHoleItemHandler.class, WhiteHoleItemHandler.class, AEApi.instance().storage().getStorageChannel(IItemStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleFluidHandler.class, WhiteHoleFluidHandler.class, AEApi.instance().storage().getStorageChannel(IFluidStorageChannel.class));
        AIApi.instance().addHandlersForMEPylon(BlackHoleEnergyHandler.class, WhiteHoleEnergyHandler.class, AEApi.instance().storage().getStorageChannel(IEnergyStorageChannel.class));

        // Check if botania loaded
        if(Loader.isModLoaded("botania") && AIConfig.enableManaFeatures) {
            AIApi.instance().addHandlersForMEPylon(BlackHoleManaHandler.class, WhiteHoleManaHandler.class, AEApi.instance().storage().getStorageChannel(IManaStorageChannel.class));
        }

        // Create maps
        activeWhiteHoleHandlers = new LinkedHashMap<>();
        activeBlackHoleHandlers = new LinkedHashMap<>();

        // Iterate over all channels
        for(IStorageChannel chan : AEApi.instance().storage().storageChannels()){
            try {
                // Get inv
                WhiteHoleSingularityInventoryHandler<?> invWhiteHole = passiveWhiteHoleHandlers.get(chan).newInstance();
                BlackHoleSingularityInventoryHandler<?> invBlackHole = passiveBlackHoleHandlers.get(chan).newInstance();

                // Set singularity
                invWhiteHole.setSingularity(operatedTile);
                invBlackHole.setSingularity(operatedTile);

                // Fill up maps
                activeBlackHoleHandlers.put(chan, invBlackHole);
                activeWhiteHoleHandlers.put(chan, invWhiteHole);

            }catch (Exception e){
                AILog.info(e.getMessage());
            }
        }

        activeHandlersLoaded = true;
    }

    public boolean hasSingularity() {
        return operatedTile != null;
    }

    @Override
    public void update() {
        super.update();

        // Call only on server
        if(!world.isRemote) {
            // Check if handlers not exist yet
            if (!activeHandlersLoaded) {
                // Init handlers
                initHandlers();
            }

            // Check if has no handled black hole
            if (!hasSingularity()) {
                // Check if active
                if (getGridNode().isActive()) {
                    tryToGetSingularity();
                }
            }

            // Check if node was active
            if (!syncActive && getGridNode().isActive()) {
                // Node wasn't active, but now it is active
                // Fire new cell array update event!
                postCellEvent(new MENetworkCellArrayUpdate());
                // Update sync
                syncActive = true;
            } else if (syncActive && !getGridNode().isActive()) {
                // Node was active, but now it not
                // Fire new cell array update event!
                postCellEvent(new MENetworkCellArrayUpdate());
                // Update sync
                syncActive = false;
            }
        }
    }

    private void tryToGetSingularity() {

        // Check if tile already has singularity
        if(hasSingularity())
            return;

        // Check if tile can indirectly see singularity
        for(int i = 1; i < 85; i++){
            // get block with offset
            IBlockState state = world.getBlockState(pos.offset(getFw(), i));

            // Check if block is singularity
            if(state.getBlock() instanceof BlockBlackHole) {
                // Set operated tile
                setSingularity((ISingularity)world.getTileEntity(pos.offset(getFw(), i)));

                // Skip other positions
                break;
            }else if(!(state.getBlock() instanceof BlockAir)){
                // ignore
                break;
            }
        }
    }

    public void setSingularity(ISingularity tileEntity) {
        // Check not null
        if(tileEntity == null)
            return;

        // Set singularity
        operatedTile = tileEntity;

        // Notify client
        NetworkHandler.sendToAllInRange(new PacketSingularitySync(this.operatedTile, this.getPos()),
                new NetworkRegistry.TargetPoint(world.provider.getDimension(), pos.getX(), pos.getY(), pos.getZ(), 64));

        // Notify singularity
        operatedTile.addListener(this);

        // Post cell array update
        postCellEvent(new MENetworkCellArrayUpdate());
    }

    @Override
    public void createAENode() {
        if(world != null) {
            if (!world.isRemote) {
                gridNode = AEApi.instance().grid().createGridNode(this);
                gridNode.updateState();

                // Fire new cell array update event!
                postCellEvent(new MENetworkCellArrayUpdate());
            }
        }
    }

    @Override
    public void blinkCell(int i) {}

    @Override
    public List<IMEInventoryHandler> getCellArray(IStorageChannel<?> iStorageChannel) {
        // Check if handlers exist
        if(!activeHandlersLoaded){
            // Create them
            initHandlers();

            // Return null array
            return new ArrayList<>();
        }

        // return empty list
        if(!hasSingularity() || !getGridNode().isActive())
            return new ArrayList<>();

        // Check if we are operating black hole
        if(operatedTile instanceof TileBlackHole)
            return singletonList(activeBlackHoleHandlers.get(iStorageChannel));
        // Check if we are operating white hole
        else
            return singletonList(activeWhiteHoleHandlers.get(iStorageChannel));
    }

    @Override
    public EnumSet<EnumFacing> getConnectableSides() {
        // Return opposite of facing side
        return EnumSet.of(getFw().getOpposite());
    }

    private EnumFacing getFw() {
        return world.getBlockState(pos).getValue(FACING).rotateY();
    }

    @Override
    public int getPriority() {
        return 0;
    }

    @Override
    public void saveChanges(@Nullable ICellInventory<?> iCellInventory) {
        // Check if inventory not null
        if (iCellInventory != null)
            // Persist inventory
            iCellInventory.persist();
        // Mark dirty
        world.markChunkDirty(pos, this);
    }

    public boolean activate(EnumHand hand, EntityPlayer p) {
        if(hand == EnumHand.MAIN_HAND) {
            if (!world.isRemote) {
                if(p.isSneaking()) {
                    AILog.chatLog("[Server] Has singularity: " + hasSingularity());
                }else{
                    tryToGetSingularity();
                }
            }else{
                if(p.isSneaking())
                    AILog.chatLog("[Client] Has singularity: " + hasSingularity());
            }
        }
        return true;
    }
}
